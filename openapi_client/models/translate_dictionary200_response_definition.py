# coding: utf-8

"""
    Kagi API

    The Kagi API provides programmatic access to data that powers our search results & more.   Quick start for all APIs:  - Create an account at [Kagi](https://kagi.com/signup) - Generate an [API key](https://kagi.com/settings?p=api) - Call the API  We have the following APIs available. ### Commercial  - Kagi Search API (invite only at the moment) - Web and News Enrichment API (public, exposes Kagi's own indexes Teclis and TinyGem) - Universal Summarizer API (public) - FastGPT API (public)  ### Free  - Kagi Small Web RSS feed (public)  ### Official Client Libraries  We offer the following libraries you can use to interact with the Kagi API. These are generated from an OpenAPI spec. If you have a language you would like to use and it's not in the list, send us a message and we will add it to the list if it is supported. Or you can use the [spec](https://wild-wombat.redocly.app/_spec/openapi.yaml?download) to build your own custom library.  - [Golang](https://github.com/kagisearch/kagi-api-golang) - [Python](https://github.com/kagisearch/kagi-api-python)  ### Unofficial Client Libraries  There also exist third party libraries for interacting with the Kagi API.  - [kagigo for Go](https://github.com/httpjamesm/kagigo) - FastGPT & Universal Summarizer - [kagi-api](https://crates.io/crates/kagi-api) for Rust - [kagi-api](https://alchemists.io/projects/kagi-api) for Ruby - [kagi-dotnet](https://github.com/patchoulish/kagi-dotnet) for C#/.NET  ### API Status  Our existing API, the \"v0\" beta API, is being replaced with a new version that will be available publicly soon. As changes are made, we will be updating the documentation below when the new features become available.  See the [Support and Community](https://help.kagi.com/kagi/support-and-community/) section for details. ### Pricing  We are in the process of moving all APIs to a post-paid tiered system, where each tier has a limit on the number of requests that can be made. If an API has a pricing section, then it is still being migrated over to the new billing system.  ### GitHub Discussions  This is the preferred venue for bug reports and feature requests.  - [Bug Reports](https://github.com/kagisearch/kagi-docs/issues/new/choose) - [Q&A Forum](https://github.com/kagisearch/kagi-docs/discussions/categories/q-a?discussions_q=category%3AQ%26A+label%3Aproduct%3Akagi_search_api) - [API Feature Requests](https://github.com/kagisearch/kagi-docs/discussions/categories/kagi-search-api-feature-requests-ideas)  ### Discord Join our [Discord](https://kagi.com/discord)! Good for quick questions or chatting about things you've made with our APIs! 

    The version of the OpenAPI document: 0.1.0
    Contact: support@kagi.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.translate_dictionary200_response_definition_primary_meaning import TranslateDictionary200ResponseDefinitionPrimaryMeaning
from openapi_client.models.translate_dictionary200_response_definition_secondary_meanings_inner import TranslateDictionary200ResponseDefinitionSecondaryMeaningsInner
from typing import Optional, Set
from typing_extensions import Self

class TranslateDictionary200ResponseDefinition(BaseModel):
    """
    Structured definition of the word
    """ # noqa: E501
    word: Optional[StrictStr] = Field(default=None, description="The word being defined (remains in word_language)")
    primary_meaning: Optional[TranslateDictionary200ResponseDefinitionPrimaryMeaning] = None
    secondary_meanings: Optional[List[TranslateDictionary200ResponseDefinitionSecondaryMeaningsInner]] = Field(default=None, description="Secondary or less common meanings")
    examples: Optional[List[StrictStr]] = Field(default=None, description="Example sentences showing usage (remains in word_language, but includes translations in parentheses when word_language differs from definition_language)")
    pronunciation: Optional[StrictStr] = Field(default=None, description="Phonetic pronunciation of the word in its original language (if available)")
    etymology: Optional[StrictStr] = Field(default=None, description="Information about word origin (translated to definition_language if available)")
    notes: Optional[StrictStr] = Field(default=None, description="Brief usage notes, cultural context, or helpful tips for language learners (translated to definition_language)")
    temporal_trend: Optional[StrictStr] = Field(default=None, description="Optional usage trend indicator. Always in English as an enum value. Only provided when trend data is clear and meaningful.")
    gender: Optional[StrictStr] = Field(default=None, description="Grammatical gender for nouns in languages that have gender. Always in English as an enum value. Only included for nouns in gendered languages.")
    plural: Optional[StrictStr] = Field(default=None, description="Plural form of the word (remains in word_language). Only included for irregular or non-standard plurals.")
    conjugation_notes: Optional[StrictStr] = Field(default=None, description="Brief notes about verb conjugation irregularities (remains in word_language). Only included for verbs with notable irregularities.")
    related_words: Optional[List[StrictStr]] = Field(default=None, description="Related words from the same root or word family (remains in word_language)")
    __properties: ClassVar[List[str]] = ["word", "primary_meaning", "secondary_meanings", "examples", "pronunciation", "etymology", "notes", "temporal_trend", "gender", "plural", "conjugation_notes", "related_words"]

    @field_validator('temporal_trend')
    def temporal_trend_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['increasing', 'stable', 'decreasing']):
            raise ValueError("must be one of enum values ('increasing', 'stable', 'decreasing')")
        return value

    @field_validator('gender')
    def gender_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['masculine', 'feminine', 'neuter', 'common']):
            raise ValueError("must be one of enum values ('masculine', 'feminine', 'neuter', 'common')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of TranslateDictionary200ResponseDefinition from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of primary_meaning
        if self.primary_meaning:
            _dict['primary_meaning'] = self.primary_meaning.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in secondary_meanings (list)
        _items = []
        if self.secondary_meanings:
            for _item_secondary_meanings in self.secondary_meanings:
                if _item_secondary_meanings:
                    _items.append(_item_secondary_meanings.to_dict())
            _dict['secondary_meanings'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of TranslateDictionary200ResponseDefinition from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "word": obj.get("word"),
            "primary_meaning": TranslateDictionary200ResponseDefinitionPrimaryMeaning.from_dict(obj["primary_meaning"]) if obj.get("primary_meaning") is not None else None,
            "secondary_meanings": [TranslateDictionary200ResponseDefinitionSecondaryMeaningsInner.from_dict(_item) for _item in obj["secondary_meanings"]] if obj.get("secondary_meanings") is not None else None,
            "examples": obj.get("examples"),
            "pronunciation": obj.get("pronunciation"),
            "etymology": obj.get("etymology"),
            "notes": obj.get("notes"),
            "temporal_trend": obj.get("temporal_trend"),
            "gender": obj.get("gender"),
            "plural": obj.get("plural"),
            "conjugation_notes": obj.get("conjugation_notes"),
            "related_words": obj.get("related_words")
        })
        return _obj


